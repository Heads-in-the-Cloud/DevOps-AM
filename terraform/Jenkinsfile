pipeline {
    agent {
        node {
            label 'aws-ready'
            customWorkspace "${AM_DEVOPS_DIRECTORY}"
        }
    }

    environment {
        // General
        AWS_PROFILE               = "${AWS_PROFILE_NAME}"
        COMMIT_HASH               = sh(returnStdout: true, script: "git rev-parse --short=8 HEAD").trim()
        SECRET_ID_PUSH            = "${AM_SECRET_ID_PUSH}"
        DEPLOY_MODE               = "dev"

        // Terraform passthrough
        TF_VAR_ECS_RECORD         = "${AM_ECS_RECORD_NAME}"
        TF_VAR_EKS_RECORD         = "${AM_EKS_RECORD_NAME}"
        TF_VAR_HOSTED_ZONE        = "${AWS_HOSTED_ZONE_ID}"
        TF_VAR_REGION_ID          = "${AWS_REGION_ID}"
        TF_VAR_SSH_BASTION_KEY    = credentials('AM_SSH_BASTION')
        TF_VAR_AWS_SECRET_ID      = "${AM_SECRET_ID}"
        TF_VAR_AZ_1               = "${AWS_REGION_AZ_1}"
        TF_VAR_AZ_2               = "${AWS_REGION_AZ_2}"
        TF_VAR_ANSIBLE_DIRECTORY  = "${AM_DEVOPS_DIRECTORY}/ansible"
        TF_VAR_DEPLOY_MODE        = "${DEPLOY_MODE}"
    }

    parameters {
        booleanParam(name: "APPLY", defaultValue: true)
    }

    stages {

        stage('Load Environment') {
            steps {
                sh 'aws configure set region ${AWS_REGION_ID} --profile ${AWS_PROFILE_NAME}'
                script {
                    // Load from AWS Secret
                    secret = sh(returnStdout: true, script: 'aws secretsmanager get-secret-value --secret-id ${AM_SECRET_ID} | jq -Mr \'.SecretString\'').trim()
                    def jsonObj = readJSON text: secret
                    env.TF_VAR_DB_USERNAME    = jsonObj.DB_USERNAME
                    env.TF_VAR_DB_PASSWORD    = jsonObj.DB_PASSWORD
                }
            }
        }

        stage('Terraform Plan') {
            steps {
                echo 'Planning terraform infrastructure'
                dir("terraform") {
                    sh 'mkdir -p plans'
                    sh 'terraform init -no-color'
                    sh 'terraform plan -out plans/plan-${COMMIT_HASH}.tf -no-color > plans/plan-${COMMIT_HASH}.txt'
                }
            }
        }

        stage('Terraform Apply') {
            when { expression { params.APPLY } }
            steps {
                echo 'Applying Terraform objects'
                dir("terraform") {
                    sh 'terraform apply -no-color -auto-approve plans/plan-${COMMIT_HASH}.tf'
                }
            }
        }

        stage('Terraform Output') {
            when { expression { params.APPLY } }
            steps {
                echo 'Exporting outputs as secrets'
                dir("terraform") {
                    sh 'terraform refresh'
                    sh 'terraform output | tr -d \'\\\"\\ \' > env.txt'
                }
            }
        }

        stage('Update Secrets') {
            when { expression { params.APPLY } }
            steps {
                echo 'Writing output to Secrets'
                script {
                    // json objects
                    secret = sh(returnStdout: true, script: 'aws secretsmanager get-secret-value --secret-id ${AM_SECRET_ID} | jq -Mr \'.SecretString\'').trim()
                    def creds = readJSON text: secret
                    def outputs = readProperties file: 'terraform/env.txt'

                    // secret keys
                    creds.AWS_VPC_ID            = outputs.AWS_VPC_ID
                    creds.AWS_RDS_ENDPOINT      = outputs.AWS_RDS_ENDPOINT
                    creds.AWS_ALB_ID            = outputs.AWS_ALB_ID
                    creds.AWS_EKS_CLUSTER_NAME  = outputs.AWS_EKS_CLUSTER_NAME
                    creds.AWS_ECS_SG            = outputs.AWS_ECS_SG

                    // rewrite secret
                    String jsonOut = writeJSON returnText: true, json: creds
                    sh "aws secretsmanager update-secret --secret-id 'arn:aws:secretsmanager:${AWS_REGION_ID}:${AWS_ACCOUNT_ID}:secret:${SECRET_ID_PUSH}' --region ${AWS_REGION_ID} --secret-string '${jsonOut}'"
                }
            }
        }

        stage('Cleanup') {
            when { expression { params.APPLY } }
            steps {
                echo 'Removing temp files'
                sh 'rm -f terraform/env.txt'
            }
        }

        // end stages
    }
}
